"""
Reservation Module - Defines reservation entity

SOLID Principles Applied:
- SRP: Reservation class has single responsibility - managing booking data
  Doesn't handle persistence, notifications, or validation (other classes do)
- Encapsulation: All attributes private with controlled access via properties

Domain Model: Represents core business concept of a room reservation
"""
from datetime import datetime
from typing import Optional
from models.room import Room


class Reservation:
    """
    Represents a room reservation with time slot and user information.
    
    Business Entity: Core domain object representing a booking transaction.
    Immutable after creation (except status changes via cancel()).
    
    Lifecycle:
    1. Created with CONFIRMED status
    2. Can be cancelled (status -> CANCELLED)
    3. Stored in repository for persistence
    """
    
    def __init__(self, reservation_id: str, room: Room, user_name: str,
                 start_time: datetime, end_time: datetime, purpose: str = ""):
        """
        Create a new reservation with all required details.
        
        Args:
            reservation_id: Unique identifier (generated by service)
            room: Room object being reserved (composition - has-a relationship)
            user_name: Person making the reservation
            start_time: Reservation start datetime
            end_time: Reservation end datetime  
            purpose: Optional description of reservation purpose
            
        Design Decision: Accept Room object not room_id for type safety
        and immediate access to room details without lookup.
        """
        # Core reservation attributes - all immutable after creation
        self._reservation_id = reservation_id
        self._room = room                    # Composition: Reservation has-a Room
        self._user_name = user_name
        self._start_time = start_time
        self._end_time = end_time
        self._purpose = purpose
        self._status = "CONFIRMED"          # Default status for new reservations
        self._created_at = datetime.now()   # Audit trail - when was it made?
    
    # Properties provide read-only access (encapsulation principle)
    # No setters = immutable reservation (except status via cancel())
    
    @property
    def reservation_id(self) -> str:
        """Unique identifier for tracking and cancellation"""
        return self._reservation_id
    
    @property
    def room(self) -> Room:
        """Room being reserved - returned as object for rich access"""
        return self._room
    
    @property
    def user_name(self) -> str:
        """Name of person who made the reservation"""
        return self._user_name
    
    @property
    def start_time(self) -> datetime:
        """When reservation begins - used for conflict detection"""
        return self._start_time
    
    @property
    def end_time(self) -> datetime:
        """When reservation ends - used for conflict detection"""
        return self._end_time
    
    @property
    def purpose(self) -> str:
        """Optional description of what reservation is for"""
        return self._purpose
    
    @property
    def status(self) -> str:
        """Current status: CONFIRMED or CANCELLED"""
        return self._status
    
    @property
    def created_at(self) -> datetime:
        """Timestamp of reservation creation for audit trail"""
        return self._created_at
    
    def cancel(self):
        """
        Cancel this reservation by changing status.
        
        Only modifiable attribute - immutable after creation except cancellation.
        SRP: Reservation knows how to cancel itself, service orchestrates.
        """
        self._status = "CANCELLED"
    
    def overlaps_with(self, start: datetime, end: datetime) -> bool:
        """
        Check if this reservation overlaps with a given time range.
        
        Overlap Logic:
        - Two time ranges overlap if one starts before the other ends
        - Used for conflict detection: Can't book same room at same time
        
        Mathematical condition:
        - Range1: [self.start, self.end]
        - Range2: [start, end]
        - Overlaps if: start1 < end2 AND start2 < end1
        
        Args:
            start: Start of time range to check
            end: End of time range to check
            
        Returns:
            True if reservations overlap, False otherwise
        """
        return (self._start_time < end) and (self._end_time > start)
    
    def __str__(self) -> str:
        """
        Human-readable string representation for logging and display.
        
        Format: "Reservation #ID - RoomName for UserName from TIME to TIME [STATUS]"
        Useful for debugging and user-facing messages.
        """
        return (f"Reservation #{self.reservation_id} - {self.room.name} "
                f"for {self.user_name} from {self.start_time.strftime('%Y-%m-%d %H:%M')} "
                f"to {self.end_time.strftime('%H:%M')} [{self.status}]")